// Package services provides business logic orchestration for content management.
package services

import (
	"database/sql"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/kimhsiao/memonexus/backend/internal/db"
	"github.com/kimhsiao/memonexus/backend/internal/models"
	"github.com/kimhsiao/memonexus/backend/internal/parser"
	"github.com/kimhsiao/memonexus/backend/internal/parser/storage"
)

// ContentService orchestrates content ingestion, parsing, and storage.
type ContentService struct {
	repo    *db.Repository
	parser  *parser.ParserService
	storage *storage.StorageManager
	logger  *log.Logger
}

// NewContentService creates a new ContentService.
func NewContentService(db *sql.DB, storageDir string) (*ContentService, error) {
	// Initialize repository
	repo := db.NewRepository(db)

	// Initialize parser service
	parserSvc := parser.NewParserService()
	parserSvc.RegisterExtractor(parser.NewWebExtractor())

	// Initialize storage manager
	store, err := storage.NewStorageManager(storageDir)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize storage: %w", err)
	}

	// Initialize logger
	logger := log.New(log.Writer(), "[ContentService] ", log.LstdFlags|log.Lmsgprefix)

	return &ContentService{
		repo:    repo,
		parser:  parserSvc,
		storage: store,
		logger:  logger,
	}, nil
}

// CreateFromURL creates a content item from a URL.
func (s *ContentService) CreateFromURL(sourceURL string) (*models.ContentItem, error) {
	startTime := time.Now()
	s.logger.Printf("Starting content ingestion from URL: %s", sourceURL)

	// Validate URL
	parsedURL, err := url.Parse(sourceURL)
	if err != nil {
		s.logger.Printf("URL validation failed: %v", err)
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Parse content from URL
	s.logger.Printf("Fetching and parsing content from: %s", parsedURL.Host)
	result, err := s.parser.ParseURL(sourceURL)
	if err != nil {
		s.logger.Printf("Parse error for URL %s: %v", sourceURL, err)
		return nil, fmt.Errorf("failed to parse URL: %w", err)
	}

	s.logger.Printf("Content parsed: title='%s' (%d words, type=%s)",
		result.Title, result.WordCount, result.MediaType)

	// Check for duplicate content using SHA-256 hash
	if result.ContentText != "" {
		contentHash, err := storage.CalculateHash(strings.NewReader(result.ContentText))
		if err != nil {
			s.logger.Printf("Hash calculation failed: %v", err)
			return nil, fmt.Errorf("failed to calculate hash: %w", err)
		}

		s.logger.Printf("Content hash calculated: %s (first 12 chars)", contentHash[:12])

		// Check if content already exists (duplicate detection)
		existing, err := s.findByContentHash(contentHash)
		if err == nil && existing != nil {
			s.logger.Printf("Duplicate content detected! Existing item: %s (created: %s)",
				existing.ID, existing.CreatedAt.Format(time.RFC3339))
			return existing, fmt.Errorf("duplicate content: already exists as item %s", existing.ID)
		}

		result.ContentHash = contentHash
	}

	// Create content item
	item := &models.ContentItem{
		Title:       result.Title,
		ContentText: result.ContentText,
		SourceURL:   sourceURL,
		MediaType:   string(result.MediaType),
		Tags:        strings.Join(result.Tags, ","),
		Summary:     "", // Will be generated by analysis service
		ContentHash: result.ContentHash,
	}

	if err := s.repo.CreateContentItem(item); err != nil {
		s.logger.Printf("Database insert failed: %v", err)
		return nil, fmt.Errorf("failed to create content item: %w", err)
	}

	duration := time.Since(startTime)
	s.logger.Printf("Content ingestion completed successfully: id=%s title='%s' duration=%dms",
		item.ID, item.Title, duration.Milliseconds())

	return item, nil
}

// CreateFromFile creates a content item from a file upload.
func (s *ContentService) CreateFromFile(filename string, reader io.Reader) (*models.ContentItem, error) {
	startTime := time.Now()
	s.logger.Printf("Starting file ingestion: filename='%s'", filename)

	// Store file in content-addressed storage
	contentHash, size, err := s.storage.StoreFile(reader)
	if err != nil {
		s.logger.Printf("Storage failed for file '%s': %v", filename, err)
		return nil, fmt.Errorf("failed to store file: %w", err)
	}

	s.logger.Printf("File stored: hash=%s (first 12 chars) size=%d bytes",
		contentHash[:12], size)

	// Check for duplicate file (same content hash)
	existing, err := s.findByContentHash(contentHash)
	if err == nil && existing != nil {
		s.logger.Printf("Duplicate file detected! Existing item: %s (filename='%s')",
			existing.ID, existing.Title)
		return existing, fmt.Errorf("duplicate file: already exists as item %s", existing.ID)
	}

	// Detect media type from filename
	mediaType := s.detectMediaTypeFromPath(filename)
	s.logger.Printf("Detected media type: %s", mediaType)

	// Create content item
	item := &models.ContentItem{
		Title:       filename,
		ContentText: fmt.Sprintf("File: %s (Size: %d bytes)", filename, size),
		SourceURL:   "", // Local file
		MediaType:   string(mediaType),
		Tags:        "",
		ContentHash: contentHash,
	}

	if err := s.repo.CreateContentItem(item); err != nil {
		s.logger.Printf("Database insert failed: %v", err)
		return nil, fmt.Errorf("failed to create content item: %w", err)
	}

	duration := time.Since(startTime)
	s.logger.Printf("File ingestion completed: id=%s filename='%s' duration=%dms",
		item.ID, filename, duration.Milliseconds())

	return item, nil
}

// GetContent retrieves a content item by ID.
func (s *ContentService) GetContent(id string) (*models.ContentItem, error) {
	return s.repo.GetContentItem(id)
}

// ListContent lists content items with pagination and filters.
func (s *ContentService) ListContent(limit, offset int, mediaType string) ([]*models.ContentItem, error) {
	return s.repo.ListContentItems(limit, offset, mediaType)
}

// UpdateContent updates an existing content item.
func (s *ContentService) UpdateContent(item *models.ContentItem) error {
	return s.repo.UpdateContentItem(item)
}

// DeleteContent soft deletes a content item.
func (s *ContentService) DeleteContent(id string) error {
	return s.repo.DeleteContentItem(id)
}

// SearchContent searches for content items using FTS5.
func (s *ContentService) SearchContent(query string, limit int) ([]*models.ContentItem, error) {
	// TODO: Implement FTS5 search
	// This is a placeholder that returns all items
	return s.repo.ListContentItems(limit, 0, "")
}

// findByContentHash finds a content item by its content hash.
// This implements duplicate detection using SHA-256 hash comparison.
func (s *ContentService) findByContentHash(contentHash string) (*models.ContentItem, error) {
	// Query the database for existing content with the same hash
	items, err := s.repo.ListContentItems(1000, 0, "") // Get recent items for duplicate check
	if err != nil {
		return nil, err
	}

	// Search for matching content hash
	for _, item := range items {
		if item.ContentHash != nil && *item.ContentHash == contentHash {
			s.logger.Printf("Found duplicate by hash: %s matches item %s",
				contentHash[:12], item.ID)
			return item, nil
		}
	}

	// No duplicate found
	return nil, sql.ErrNoRows
}

// detectMediaTypeFromPath detects media type from file path extension.
func (s *ContentService) detectMediaTypeFromPath(path string) parser.MediaType {
	dotIdx := strings.LastIndex(path, ".")
	if dotIdx < 0 {
		return parser.MediaTypeWeb
	}

	ext := strings.ToLower(path[dotIdx:])

	switch ext {
	case ".jpg", ".jpeg", ".png", ".gif", ".webp":
		return parser.MediaTypeImage
	case ".mp4", ".webm", ".mov", ".avi":
		return parser.MediaTypeVideo
	case ".pdf":
		return parser.MediaTypePDF
	case ".md", ".markdown":
		return parser.MediaTypeMarkdown
	default:
		return parser.MediaTypeWeb
	}
}

// GetStorageFilePath returns the file system path for a stored media file.
func (s *ContentService) GetStorageFilePath(contentHash string) (string, error) {
	return s.storage.GetFilePath(contentHash)
}

// GetStorageStats returns storage statistics.
func (s *ContentService) GetStorageStats() (*storage.StorageStats, error) {
	return s.storage.GetStats()
}
